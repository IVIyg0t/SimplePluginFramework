{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SimplePluginFramework","text":"<p>SPF is a simple, low-code, dependency free plugin framework following the design principals laid out by Marty Alchin in his blog post A Simple Plugin Framework</p> <p>If you like, you can visit our Docs pages.</p>"},{"location":"#install","title":"Install","text":"<p><code>pip install simple-plugin-framework</code></p>"},{"location":"#fundamentals-of-a-plugin-framework","title":"Fundamentals Of A Plugin Framework","text":"<p>SPF is a dead simple, low code, pure python plugin framework.  The framework satisfies the three primary requirements for a plugin based architecture:</p>"},{"location":"#declaration","title":"Declaration","text":"<p>The framework needs to provide a mechanism for declaring a mount point for plugins</p> <p>How</p> <p>Declare a mount point by inheriting from <code>spf.PluginMount</code> metaclass.</p> <pre><code>from spf import PluginMount\n\nclass MyMountPoint(metaclass=PluginMount):\n    entry_point = \"my_mount_point\"\n</code></pre>"},{"location":"#registration","title":"Registration","text":"<p>The framework needs to be able to register a plugin to a declared mount point.</p> <p>How</p> <p>Register a mount point by inheriting from your defined <code>MountPoint</code> class.</p> <pre><code>class MyPlugin(MyMountPoint):\n    pass\n</code></pre>"},{"location":"#discovery","title":"Discovery","text":"<p>The framework needs to be able to discover what plugins are available.</p> <p>How</p> <p>Discovery can happen in two ways...</p> <ol> <li>If the plugin is imported, then the MountPoint discovers it:</li> </ol> <p><pre><code>from my_pkg import MyMountPoint\nfrom my_plugin import MyPlugin\n\nprint(MyMountPoint.plugins)\n\n&gt; {'MyPlugin': &lt;class \"__main__.MyPlugin\"&gt;}\n</code></pre> 2. You can call the <code>MyMountPoint.load()</code> method to load plugins via <code>entry_points</code>.</p> <p>Plugins can be provided to the mount points via python <code>entry_points</code>.  Entry points can be provided by various build tools like setuptools or poetry</p> <pre><code>from my_pkg import MyMountPoint\n\nMyMountPoint.load()\nprint(MyMountPoint.plugins)\n\n&gt; {'MyPlugin': &lt;class \"__main__.MyPlugin\"&gt;}\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#010-2023-11-15","title":"[0.1.0] - 2023-11-15","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Initial impl of PluginMount class</li> <li>Initial documentation</li> <li>Initial Pypi artifact</li> </ul>"},{"location":"API/PluginMount/","title":"PluginMount","text":""},{"location":"API/PluginMount/#spf.PluginMount","title":"<code>PluginMount</code>","text":""},{"location":"API/PluginMount/#spf.PluginMount.PluginMount","title":"<code>PluginMount(name, bases, attrs)</code>","text":"<p>             Bases: <code>ABCMeta</code></p> Source code in <code>src/spf/PluginMount.py</code> <pre><code>def __init__(\n    cls: Any, name: str, bases: List[Any], attrs: List[Any]\n) -&gt; None:  # sourcery skip: instance-method-first-arg-name\n    if not hasattr(cls, \"plugins\"):\n        # This branch only executes when processing the mount point itself.\n        # So, since this is a new plugin type, not an implementation, this\n        # class shouldn't be registered as a plugin. Instead, it sets up a\n        # list where plugins can be registered later.\n        cls.plugins = {}\n    else:\n        # This must be a plugin implementation, which should be registered.\n        # Simply appending it to the list is all that's needed to keep\n        # track of it later.\n        cls.verify()\n        cls.plugins[cls.__name__] = cls\n</code></pre>"},{"location":"API/PluginMount/#spf.PluginMount.PluginMount.load","title":"<code>load()</code>","text":"<p>Loads all plugins registered under the specified entry point.</p> RETURNS DESCRIPTION <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; MyMountPoint.load()\n</code></pre> Source code in <code>src/spf/PluginMount.py</code> <pre><code>def load(cls) -&gt; None:  # sourcery skip: instance-method-first-arg-name\n    \"\"\"Loads all plugins registered under the specified entry point.\n\n    Returns\n    -------\n    None\n\n    Examples\n    --------\n    &gt;&gt;&gt; MyMountPoint.load()\n    \"\"\"\n    if cls == PluginMount:\n        return None\n\n    eps = (\n        pkg_resources.iter_entry_points(cls.entry_point)\n        if USE_LEGACY\n        else entry_points().select(group=cls.entry_point)\n    )\n\n    for ep in eps:\n        ep.load()\n</code></pre>"},{"location":"API/PluginMount/#spf.PluginMount.PluginMount.verify","title":"<code>verify()</code>","text":"<p>Verifies that the required static properties are implemented by the class.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If any of the required static properties are not implemented.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; MyMountPoint.verify()\n</code></pre> Source code in <code>src/spf/PluginMount.py</code> <pre><code>def verify(cls):  # sourcery skip: instance-method-first-arg-name\n    \"\"\"Verifies that the required static properties are implemented by the class.\n\n    Raises\n    ------\n    NotImplementedError\n        If any of the required static properties are not implemented.\n\n    Examples\n    --------\n\n    &gt;&gt;&gt; MyMountPoint.verify()\n    \"\"\"\n    base = cls.__mro__[-2]\n    if not_implemented := set(cls.REQUIRED_STATIC_PROPERTIES) - set(base.__dict__.keys()):\n        raise NotImplementedError(\n            f\"Attribute(s) {not_implemented} not implemented by class {base.__name__}\"\n        )\n</code></pre>"},{"location":"Guides/HelloWorld/","title":"HelloWorld","text":"<p>What better way to demonstrate how this works than with a simple hello world?</p>"},{"location":"Notebooks/HelloWorld/","title":"Hello World","text":"<p>What better way to demonstrate how this works than with a simple hello world?</p> In\u00a0[3]: Copied! <pre>from spf.PluginMount import PluginMount\nfrom abc import abstractmethod\n</pre> from spf.PluginMount import PluginMount from abc import abstractmethod In\u00a0[4]: Copied! <pre>class HelloMountPoint(metaclass=PluginMount):\n    entry_point = \"hello_world\"\n\n    @property\n    @abstractmethod\n    def hello(self) -&gt; str:\n        pass\n</pre> class HelloMountPoint(metaclass=PluginMount):     entry_point = \"hello_world\"      @property     @abstractmethod     def hello(self) -&gt; str:         pass In\u00a0[5]: Copied! <pre>class HelloWorldPlugin(HelloMountPoint):\n    @property\n    def hello(self) -&gt; str:\n        return \"Hello, world.\"\n</pre> class HelloWorldPlugin(HelloMountPoint):     @property     def hello(self) -&gt; str:         return \"Hello, world.\" In\u00a0[6]: Copied! <pre>class HelloUniversePlugin(HelloMountPoint):\n    @property\n    def hello(self) -&gt; str:\n        return \"Hello, universe.\"\n</pre> class HelloUniversePlugin(HelloMountPoint):     @property     def hello(self) -&gt; str:         return \"Hello, universe.\" In\u00a0[7]: Copied! <pre>HelloMountPoint.plugins\n</pre> HelloMountPoint.plugins Out[7]: <pre>{'HelloWorldPlugin': __main__.HelloWorldPlugin,\n 'HelloUniversePlugin': __main__.HelloUniversePlugin}</pre> In\u00a0[11]: Copied! <pre>plugins = HelloMountPoint.plugins\n\nfor name, plugin in plugins.items():\n    print(plugin().hello)\n</pre> plugins = HelloMountPoint.plugins  for name, plugin in plugins.items():     print(plugin().hello) <pre>Hello, world.\nHello, universe.\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"}]}